1. 연산자(operator)
연산자(operator)와 피연산자(operand)
연산자는 ‘연산을 수행하는 기호(+, -, *, / 등)’이다.
피연산자는 연산자의 작업 대상(변수,상수, 리터럴, 수식)이다.

연산자의 종류
단항연산자: +, -, (타입), ++, –, ~, !
이항연산자
산술: +, -, *, /, %, <<, >>, >>>
비교: >, <, >=, <=, ==, !=
논리: &&, ||, &, ^, |
대입연산자: =
기타
형변환 연산자: (type)
삼항 연산자: ? :
instanceof연산자

연산자의 우선순위
괄호의 우선순위가 제일 높다.
산술 > 비교 > 논리 > 대입
대입은 제일 마지막에 수행된다.
단항 > 이항 > 삼항
연산자의 연산 진행방향은 왼쪽에서 오른쪽(→)이다.
단, 단항, 대입연산자만 오른쪽에서 왼쪽(←)이다.
주의사항
쉬프트 연산자(<<, >>, >>>)는 덧셈연산자보다 우선순위가 낮다.
ex) x<< 2+1 → x<<(2+1)
AND를 의미하는 '&'와 '&&'가 OR를 의미하는 ‘|’와 ‘||’보다 우선순위가 높다.
ex) x<-1 || x>3 && x<5 → x<-1 || (x>3 && x<5)
비트 연산자(&)는 비교 연산자(==)보다 우선순위가 낮으므로 비교연산 후에 비트연산이 수행된다.
ex) data & 0xFF == 0 → data & (0xFF == 0)

산술 변환(usual arithmetic conversion)
연산 수행 직전에 발생하는 피연산자의 자동 형변환
피연산자 중 표현범위가 큰 타입으로 형변환한다.
피연산자의 타입이 int보다 작은 타입은 int로 변환한다
byte, char, short → int
실수 → 정수 형변환은 에러 발생. 왜냐하면 값 손실이 발생하기 때문.

2. 단항 연산자
증감 연산자 ++ –-
타입	
설명
전위형
값이 참조되기 전에 증가시킨다.
후위형	


값이 참조된 후에 증가시킨다.

그러나 '++i;'와 'i++;’처럼 증감연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우에는 전위형과 후위형의 차이가 없다.

부호 연산자 + -
'+'는 피연산자에 1을 곱하고 '-'는 피연산자에 -1을 곱한다.
논리부정연산자(!): true는 false로, false는 true로 
		     피연산자가 boolean일 때만 사용 가능 

3. 산술 연산자
사칙연산자 + - * / 
나머지 연산자 %
나누는 수(오른쪽 피연산자)로 0을 사용할 수 없다.
주로 짝수. 홀수 또는 배수 검사 등에 주로 사용된다.

4. 비교 연산자
대소비교 연산자: <, >, <=, >=
기본형 중에서는 boolean형을 제외한 나머지 자료형에 다 사용할 수 있지만 참조형에는 시용할 수 없다.

등가비교 연산자: ==, !=
기본형은 물론 참조형, 즉 모든 자료형에 사용할 수 있다

문자열의 비교
두 문자열을 비교할 때는. 비교 연산자 '=='대신 equals( )라는 메서드를 사용해야 한다. 
String str = new String(“abc”);
boolean result = str.equals(“abc”);

5. 논리연산자
피연산자가 반드시 boolean이어야 하며 연산결과도 boolean이다.

논리연산자 - &&, ||, ?
&&(AND 결합) 
피연산자 양쪽 모두 true이어야 true를 결과로 얻는다.
x가 false이면, x && y는 항상 false이다.

||(OR 결합) 
피연산자 중 어느 한 쪽만 true면 true를 결과로 얻는다.
x가 true이면, x || y는 항상 true이다.

논리 부정 연산자 !
피연산자가 true이면 false를. false면 true를 결과로 반환한다. 간단히 말해서. true와 false를 반대로 바꾸는 것이다.

비트 연산자 & | ^ ~ << >>
피연산자를 비트단위로 논리 연산한다.
| (OR연산자)
피연산자 중 한 쪽의 값이 1이면. 1을 결과로 얻는다. 그 외에는 0을 얻는다. 
& (AND연산자)
피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다. 
^ (XOR 연산자)
 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.

비트 전환 연산자 ~ 
피연산자를 2진수로 표현했을 때. 0은 1로. 1은 0으로 바꾼다. 논리부정 연산자 ‘!’와 유사하다.
‘1의 보수’ 연산자

쉬프트 연산자 << >>
x << n은 x * 2n의 결과와 같다.
x >> n은 x / 2n의 결과와 같다.

6. 그 외의 연산자
삼항 연산자 ? : 
조건식 ? 식1 : 식2
조건식의 연산결과가 true이면 ‘식1'의 결과를 반환하고 false이면 ‘식2'의 결과를 반환한다.

대입 연산자 = , op(다른 연산자)=
오른쪽 피연산자의 값(식이라면 평가값)을 왼쪽 피연산자에 저장한다. 그리고 저장된 값을 연산결과로 반환한다. 
단, 왼쪽 피연산자는 상수가 아니어야 한다.




lvalue와 rvalue
대입 연산자의 왼쪽 피연산자를 ‘lvalue(left value)’이라 하고, 오른쪽 피연산자를 ‘rvalue(right value)’라고 한다.
x = 3

int i = 0; 
3 = i + 3;  // 에러. lvalue가 값을 저장할 수 있는 공간이 아니다.
i+3=i; // 에러. lvalue의 연산결과는 리터럴 (i+3 = 0+3 = 3)
final int MAX = 3;  // 변수 앞에 키워드 final을 붙이면 상수가 된다. 
MAX = 10; // 에러. 상수(MAX)에 새로운 값을 저장할 수 없다.

복합 대입 연산자
i += 3;		=	i = i + 3;
i *= 10 + j	=	i = i * (10 + j);


